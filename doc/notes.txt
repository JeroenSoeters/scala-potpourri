--
MONOIDS
--

how to think about it?
monad is monoid in catgeory of endofunctiors

learn to think of what a monoid is and not be afraid of monadic stuff

why to learn?
monoids allow you to do pairwise operations on a list and guarantee that you can do that in a parallelized way

for a monad to be a monoid you need those mathematical rules:
- op must be a closure T -> T -> T
- identiy x + I = x (zero operator)
- associativity (x + x) + z = x + (y + z)

monad laws:
- lef identity
- right identity
- associativity

color adding the stupid way

create trait

implement colour add monoid

List.reduce it

scalacheck awesomeness

so: because of the close operation we can combine the pair and because of the associativity we can parallelize an incrementalize and b/c of identity this stuff is actually possible

--
MONADS
--

start with something simple, option monad

division example

(contrived example, but pattern is common)

let's implement it

sealed trait Maybe[+A] {
 
  // >>=
  def flatMap[B](f: A => Maybe[B]): Maybe[B]
}
 
case class Just[+A](a: A) extends Maybe[A] {
  override def flatMap[B](f: A => Maybe[B]) = f(a)
}
 
// Nothing in the Haskel example
case object MaybeNot extends Maybe[Nothing] {
  override def flatMap[B](f: Nothing => Maybe[B]) = MaybeNot
}

A monad is defined in the wikibook, and in Wikipedia, as having three parts:
A type constructor
A unit function, commonly called return in Haskell
A binding operation, commonly called >>= in Haskell

Type Constructor
In Scala, a type constructor is just the definition of a type that has a type parameter. In our case, the type definition is trait Maybe[+A]. The A is the underlying data type. The + indicates covariance, which means that if an A is a B, then a Maybe[A] is also a Maybe[B]. This is the typical type variance for a container where, once constructed, we can read out what is contained inside, but we cannot write in to the container. In other words, an immutable container.

Because MaybeNot is an empty container, we can use the same MaybeNot instance for all maybes, regardless of the type parameter. To achieve this, we make the type parameter the special Scala type Nothing, which is a sub-type of every other type. Thanks to the covariance of A in Maybe[+A], the type parameter of MaybeNot matches regardless of what is chosen for A.

We use MaybeNot here where the Haskell example uses Nothing, to avoid confusion with Scala's Nothing.

Unit Function
The unit function is a function from the contained type to the container type, i.e., from A to Maybe[A]. The unit function is typically named return in Haskell. A natural place to put a function like this in Scala is as an apply method of a companion object. Because apply methods are automatically generated by the compiler for case classes, we get our unit function for free in method Just.apply(A).

Binding Operation
The binding operation, as a Scala function, would have the following signature:
def bind[A, B](Maybe[A])(A => Maybe[B]): Maybe[B]
In Haskell, this is implemented as a function named >>=. As Scala is an object oriented language, it is natural to implement this as a method on type Maybe[A]. It's also customary to name such Scala methods flatMap.

As you can see, we make use of polymorphism in the above definition of flatMap. This might not please the hard-core functional programmers out there. A non-polymorphic implementation can be achieved with the Scala match operator, and is a more direct translation of the Haskell example:

sealed trait Maybe[+A] {
 
  // >>=
  def flatMap[B](f: A => Maybe[B]): Maybe[B] = this match {
    case Just(a) => f(a)
    case MaybeNot => MaybeNot
  }
}

back to implementation, write divide with Maybe, flatmap and for comprehension

so monad is a pattern to deal with side effects and failures

They must obey the three provided laws: left unit, right unit, and associativity

--
ADT's
--

all this really does is it's an int when I want it an int

use the type system as a tool to inforce invariance! 
choose your datatypes that states that are illegal don't show up

imaginary module for managing imaginary connection

2 types
3 states and trait

connectioninfo is record of all info u keep

state -> connection state
last ping and last id, various protocols occasional pings as keepalive mechanism
session some id when new session is constructed
2 times

few good things to say
- it keeps track of a bunch of relevant info
- fairly readable

interesting: lot of option types!

java probably nullable

tricky little invariants:
- last ping id + time
- session id only when connected
- when initiated only when connecting, be careful
- when disconnected only makes sense when disconnected if disconnected u better have it

bunch of invariants
nothing about htis type helps u to enforce these invariants

strongly encourage to refactor the types so that the invariants are embedded in the types instead of in the logic around the types

-> show better version

see why the server is in there and everything esle is kicked out?
why did I make that design choice?

note there's no option.. whatever state connection

exactly what this us doing, pyshing stuff in to the invariants

now there's no illegal states, that's the key way why this is better than the previous interface

one other thing, tuple


this is genius about algebraic datatypes
there's a deeply mathematical thing going on here

2 basic components, product types, sum types
carthesian products, disjoint sums

often misrepresented in literature, binary tree example

by combining those 2 together
